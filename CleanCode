## aaa

# Clean Code
## 3 Laws of TDD
Rule - 1 : You may not write any production code without a failing unit test first 
Rule - 2 : Write only enough test code as is sufficient enough to fail (not compiling=failing) usage of undeclared class 
Rule - 3 : Only write a minimal code that makes the failing test pass. declare the class only

Test code is as important as production code. Make it readable
Clean tests folllow 5 other rules as FIRST
Fast(runs quickly) Independent(should not depend on each other) Repeatable(All environments) Self-Validating(boolean output fail or pass)  Timely(before production code) 



In a multithreaded application, two or more threads access a shared resource at the same time the results are confusing.
This situation is caled a rece condition. To overcome this problem we use  synchronized  keyword for the resource
 to implement a mutex we use synchronized  keyword. Only one thread can access a resource at a time.
 




////////////////ReentrantLock  ///////////////////////
//provides more flexibility and control than the synchronized

import java.util.concurrent.locks.ReentrantLock;

class SayHello {

    private ReentrantLock retrantLock = new ReentrantLock();


    void greeting(String threadName) {
        try {
            //with or without ReentrantLock
            //retrantLock.lock();
            for (int i = 1; i <= 5; i++) {
                System.out.println("hello " + threadName);
            }
        } finally {
            // retrantLock.unlock();
        }

    }

}

class MyThread extends Thread {

    SayHello hello;
    String threadName;

    MyThread(SayHello hello, String nameThread) {
        this.hello = hello;
        this.threadName = nameThread;
    }

    public void run() {

        hello.greeting(threadName);

    }

}

public class JavaApplication31 {

    public static void main(String[] args) {

        SayHello obj = new SayHello();//only one resource
        MyThread t1 = new MyThread(obj, "thread-1");
        MyThread t2 = new MyThread(obj, "thread-2");
        t1.start();
        t2.start();

    }

}



////////////////Mutex(Syncronized)  ///////////////////////

class SayHello {

//with or without keyword
//  synchronized 
    void greeting(String threadName) {
        for (int i = 1; i <= 5; i++) {
            System.out.println("hello " + threadName);
        }
    }

}

class MyThread extends Thread {

    SayHello hello;
    String threadName;

    MyThread(SayHello hello, String nameThread) {
        this.hello = hello;
        this.threadName = nameThread;
    }

    public void run() {

        hello.greeting(threadName);

    }

}

public class MutexTest {

    public static void main(String[] args) {
        SayHello obj = new SayHello();//only one resource
        MyThread t1 = new MyThread(obj, "thread-1");
        MyThread t2 = new MyThread(obj, "thread-2");
        t1.start();
        t2.start();

    }

}





///////////////Semaphore 3 type binary,counting,mutex ex:printers browser tabs///////////////////////////////



import java.util.concurrent.Semaphore;

class SayHello {

    private Semaphore semaphore = new Semaphore(1);

    void greeting(String threadName) {
        try {
            //with or without Semaphore
            semaphore.acquire();
            for (int i = 1; i <= 5; i++) {
                System.out.println("hello " + threadName);
            }
        } catch (Exception ex) {
        } finally {
            semaphore.release();
        }

    }

}

class MyThread extends Thread {

    SayHello hello;
    String threadName;

    MyThread(SayHello hello, String nameThread) {
        this.hello = hello;
        this.threadName = nameThread;
    }

    public void run() {

        hello.greeting(threadName);

    }

}

public class JavaApplication1 {

    public static void main(String[] args) {

        SayHello obj = new SayHello();//only one resource
        MyThread t1 = new MyThread(obj, "thread-1");
        MyThread t2 = new MyThread(obj, "thread-2");
		MyThread t2 = new MyThread(obj, "thread-3");
		MyThread t2 = new MyThread(obj, "thread-4");
        t1.start();
        t2.start();
		

    }

}





4 conditions required for deadlock to occur
1-Mutual exclusion
    
2-Hold and wait 
    
3- No preemption
    
4- Circular wait


https://java-source.net/open-source/testing-tools
